from unittest.mock import patch, MagicMock

from pytest_mock import MockFixture
from src.agents.planner.planner import Planner
from src.logger import Logger
from src.config import Config


class TestPlanner:
    def test_parse_response(self, mocker: MockFixture):
        mocker.patch.object(Config, '__new__', return_value=None)
        mocker.patch.object(Logger, '__init__', return_value=None)


        # This response is generated by the prompt, "Please create a chess game in a Java Gradle project."
        response = """```
Project Name: ChessMate Gradle Game

Your Reply to the Human Prompter: Sure, I will create a step-by-step plan to build a Chess game in a Java Gradle project.

Current Focus: The main focus is to outline the stepwise process of setting up a Gradle project, designing the chess game logic and encapsulating the rules.

Plan:
- [ ] Step 1: Set up a new Gradle project using an IDE like IntelliJ IDEA, setting the programming language to Java.
- [ ] Step 2: Structure the project by creating packages for different game components - 'board', 'pieces', 'player', and 'game'.
- [ ] Step 3: Begin coding the chess 'pieces' package. Each piece (pawn, rook, knight, bishop, queen, and king) should be a class extending from an abstract class 'Piece'.
- [ ] Step 4: Within each 'Piece' subclass, define unique movements based on standard chess rules. For example, a knight can move in a 'L' pattern.
- [ ] Step 5: Move onto the 'board' package and create a class 'Board'. It should contain a 8x8 grid and the initial arrangement of the pieces.
- [ ] Step 6: Create a 'Player' class in the 'player' package. Player class should have player's information and current state of its pieces. Write functions to handle player's moves.
- [ ] Step 7: Define game logic in 'game' package, like switching turns between players, checking checkmate, or stalemate conditions.
- [ ] Step 8: Implement a simple console-based user interface to interact with the game. The user interface will show the board state and receive the user's actions.
- [ ] Step 9: Test the game extensively, check all the rules of chess game are applied, and each piece is moving as it should in the game.
- [ ] Step 10: Finally, build the Gradle project and run the tests. If vital, debug and refactor code.

Summary: The plan involves setting up a Gradle project, breaking down the chess game into components and implementing them step by step. The main considerations are creating accurate game logic and applying all chess rules. The primary challenge could be implementing complex chess rules, such as en passant and castling. Developing a user-friendly interface can also be improved in the future.
```"""
        expected_result = {
            "project": "ChessMate Gradle Game",
            "reply": "Sure, I will create a step-by-step plan to build a Chess game in a Java Gradle project.",
            "focus": "The main focus is to outline the stepwise process of setting up a Gradle project, designing the chess game logic and encapsulating the rules.",
            "summary": "The plan involves setting up a Gradle project, breaking down the chess game into components and implementing them step by step. The main considerations are creating accurate game logic and applying all chess rules. The primary challenge could be implementing complex chess rules, such as en passant and castling. Developing a user-friendly interface can also be improved in the future.",
        }

        planner = Planner("AZURE GPT")
        assert planner.parse_response(response) == expected_result


#     def test_execute_with_actual_llm(self, mocker):
#         # mocker.patch.object(src.config.Config, '__new__', return_value=src.config.Config)
#         # mocker.patch.object(src.config.Config, 'get_projects_dir', return_value='/fakepath/project-name')
#         # mocker.patch.object(src.logger.Logger, '__init__', return_value=None))
#
#         prompt = "Please create a chess game in a Java Gradle project."
#         project_name = "Project Name"
#
#         planner = Planner("AZURE GPT")
#         result = planner.execute(prompt, project_name)
#         print(result)
#
#         # Sample output:
#         """
#         ```
# Project Name: JavaChessGame
#
# Your Reply to the Human Prompter: Sure, I can assist in creating a Gradle project for a Chess Game using Java. The plan will cover everything from setting up the environment to the final integration.
#
# Current Focus: Creating a chess game with a graphical interface and implementing the game logic in Java with Gradle build tool.
#
# Plan:
# - [ ] Step 1: Install the required softwares (Java JDK and IDE like IntelliJ or Eclipse), as well as Gradle, if not already installed.
# - [ ] Step 2: Initialize a Gradle project with Java as base language, and the application and shadow JAR plugins. This can be done via IDE or command line.
# - [ ] Step 3: Create a class hierarchy for the chesspieces. This could include a base class like ChessPiece and subclasses for the various types of pieces (King, Queen, etc).
# - [ ] Step 4: Implement the methods for each different ChessPiece subclasses. The methods should dictate how the pieces can move on the board.
# - [ ] Step 5: Implement the Chessboard class. This class should manage the state of a 8x8 chessboard and validate moves for pieces.
# - [ ] Step 6: Create Player class to keep track of each player's pieces and states (in check, checkmate, etc).
# - [ ] Step 7: Implement the game logic such as move sequences, and rules of the game, including capturing pieces, castling, en passant, etc.
# - [ ] Step 8: Setup a graphical user interface (GUI). You may use JavaFX or Swing for this. The GUI should update after every move on the board.
# - [ ] Step 9: Integrate the GUI with the backend chess game logic.
# - [ ] Step 10: Test the game thoroughly by playing games until completion, and ensuring that all special cases (castling, en passant, check, checkmate) work properly.
# - [ ] Step 11: Once all testing is done, build the JAR file using shadowJar Gradle task so it can be executed independently.
#
# Summary: The project involves creating a Gradle project, implementing the chess game rules using Java class hierarchy, creating a graphical user interface, integrating the frontend and backend, and finally building the executable JAR file. Some complexities to consider involve implementing all the specific rules of chess, and making sure the graphical user interface accurately reflects the game state.
# ```
#         """
#
